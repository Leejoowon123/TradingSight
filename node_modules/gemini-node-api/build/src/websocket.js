import { EventEmitter } from "node:events";
import { stringify } from "node:querystring";
import Websocket from "ws";
import { DefaultSymbol } from "./public.js";
import { SignRequest } from "./signer.js";
export const WsUri = "wss://api.gemini.com";
export const SandboxWsUri = "wss://api.sandbox.gemini.com";
export class WebsocketClient extends EventEmitter {
  #key;
  #secret;
  #nonce;
  wsUri;
  symbol;
  sockets;
  constructor({
    symbol = DefaultSymbol,
    sandbox = false,
    wsUri = sandbox ? SandboxWsUri : WsUri,
    key,
    secret,
  } = {}) {
    super();
    this.wsUri = wsUri;
    this.symbol = symbol;
    this.sockets = {};
    if (key && secret) {
      this.#key = key;
      this.#secret = secret;
    }
    this.#nonce = () => Date.now();
  }
  /** Connect to the public API (V1) that streams all the market data on a given symbol. */
  async connectMarket({ symbol = this.symbol, ...qs } = {}) {
    const url = new URL(`/v1/marketdata/${symbol}`, this.wsUri);
    url.search = stringify({ ...qs });
    await this.#connectWS(symbol, url);
  }
  /** Disconnect from the public API (V1). */
  async disconnectMarket({ symbol = this.symbol } = {}) {
    await this.#disconnectWS(this.sockets[symbol]);
  }
  /** Connect to the private API that gives you information about your orders in real time. */
  async connectOrders({ account, ...qs } = {}) {
    if (!this.#key || !this.#secret) {
      throw new Error("`connectOrders` requires both `key` and `secret`");
    }
    const request = "/v1/order/events";
    const url = new URL(request, this.wsUri);
    url.search = stringify({ ...qs });
    const options = { request, nonce: this.nonce() };
    if (account) {
      options.account = account;
    }
    const payload = Buffer.from(JSON.stringify(options)).toString("base64");
    const signedPayload = SignRequest({
      key: this.#key,
      secret: this.#secret,
      payload,
    });
    await this.#connectWS("orders", url, { ...signedPayload });
  }
  /** Disconnect from the private API. */
  async disconnectOrders() {
    await this.#disconnectWS(this.sockets.orders);
  }
  /** Connect to the public API (V2) that can stream all market and candle data across books. */
  async connect() {
    const url = new URL("/v2/marketdata", this.wsUri);
    await this.#connectWS("v2", url);
  }
  /** Disconnect from the public API (V2). */
  async disconnect() {
    await this.#disconnectWS(this.sockets.v2);
  }
  /** Subscribe to data feeds (V2). */
  async subscribe(subscriptions) {
    await this.#sendMessage({ type: "subscribe", subscriptions });
  }
  /** Unsubscribe from data feeds (V2). */
  async unsubscribe(subscriptions) {
    await this.#sendMessage({ type: "unsubscribe", subscriptions });
  }
  async #sendMessage(data) {
    const message = JSON.stringify(data);
    const { v2: ws } = this.sockets;
    if (!ws) {
      throw new Error("Websocket is not initialized");
    }
    await new Promise((resolve, reject) => {
      ws.send(message, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
  async #connectWS(symbol, url, headers) {
    switch (this.sockets[symbol]?.readyState) {
      case Websocket.CLOSING:
      case Websocket.CONNECTING:
        throw new Error(
          `Could not connect. State: ${this.sockets[symbol].readyState}`
        );
      case Websocket.OPEN:
        return;
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      this.sockets[symbol] = new Websocket(url, { headers: { ...headers } });
      this.sockets[symbol]
        .once("open", resolve)
        .once("error", reject)
        .on("message", (data) => {
          try {
            const message = JSON.parse(data);
            this.emit("message", message, symbol);
          } catch (error) {
            this.emit("error", error, symbol);
          }
        })
        .on("open", () => {
          this.emit("open", symbol);
        })
        .on("close", () => {
          this.emit("close", symbol);
        })
        .on("error", (error) => {
          if (error) {
            this.emit("error", error, symbol);
          }
        });
    });
  }
  async #disconnectWS(ws) {
    switch (ws?.readyState) {
      case Websocket.CLOSED:
        return;
      case Websocket.CLOSING:
      case Websocket.CONNECTING:
        throw new Error(`Could not disconnect. State: ${ws.readyState}`);
      default:
        break;
    }
    await new Promise((resolve, reject) => {
      if (!ws) {
        resolve();
      } else {
        ws.once("error", reject).once("close", resolve).close();
      }
    });
  }
  set nonce(nonce) {
    this.#nonce = nonce;
  }
  get nonce() {
    return this.#nonce;
  }
}
