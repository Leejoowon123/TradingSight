import { PublicClient, PublicClientOptions, SymbolFilter } from "./public.js";
import type { RequestInit } from "node-fetch";
export interface AccountName {
  account?: string;
}
export declare type OrderEexecutionOptions =
  | "maker-or-cancel"
  | "immediate-or-cancel"
  | "fill-or-kill"
  | "auction-only"
  | "indication-of-interest";
export declare type BasicOrderOptions = AccountName & {
  client_order_id?: string;
  amount: number;
  min_amount?: number;
  price: number;
  type: "exchange limit" | "exchange stop limit";
  options?: [OrderEexecutionOptions];
  stop_price?: number;
} & SymbolFilter;
export interface OrderOptions extends BasicOrderOptions {
  side: "buy" | "sell";
}
export interface OrderID extends AccountName {
  order_id: number;
  client_order_id?: string;
  include_trades?: boolean;
}
export declare type PastTradesFilter = SymbolFilter & {
  limit_trades?: number;
  timestamp?: number;
} & AccountName;
export interface BaseClearingOrder extends SymbolFilter {
  amount: number;
  price: number;
  side: "buy" | "sell";
  expires_in_hrs: number;
}
export interface ClearingOrderOptions extends BaseClearingOrder {
  counterparty_id?: string;
}
export interface BrokerOrderOptions extends BaseClearingOrder {
  target_counterparty_id: string;
  source_counterparty_id: string;
}
export interface ClearingOrderID {
  clearing_id: string;
}
export interface ConfirmClearingOptions {
  clearing_id: string;
  symbol?: string;
  amount: number;
  price: number;
  side: "buy" | "sell";
}
export interface NotionalBalancesOptions extends AccountName {
  currency?: string;
}
export interface TransferFilter extends AccountName {
  timestamp?: number;
  limit_transfers?: number;
}
export interface DepositAddressesFilter extends AccountName {
  network: string;
}
export interface NewAddressFilter extends AccountName {
  currency: string;
  label?: string;
  legacy?: boolean;
}
export interface WithdrawCryptoFilter extends AccountName {
  currency: string;
  address: string;
  amount: number;
}
export interface InternalTransferFilter {
  currency: string;
  sourceAccount: string;
  targetAccount: string;
  amount: number;
}
export interface AddBankOptions extends AccountName {
  /** Account number of bank account to be added */
  accountnumber: string;
  /** Routing number of bank account to be added */
  routing: string;
  /** Type of bank account to be added */
  type: "checking" | "savings";
  /** The name of the bank account as shown on your account statements */
  name: string;
}
export interface SENWithdrawOptions extends AccountName {
  /** Unique ID for your SEN bank account */
  bankId: string;
  /** Amount (USD) to transfer to your account */
  amount: string;
}
export interface AccountDetails {
  account: {
    accountName: string;
    shortName: string;
    type: string;
    created: string;
  };
  users: {
    name: string;
    lastSignIn: string;
    status: string;
    countryCode: string;
    isVerified: boolean;
  }[];
  memo_reference_code: string;
}
export interface Account {
  name: string;
  type?: "exchange" | "custody";
}
export interface WithdrawGUSDFilter extends AccountName {
  address: string;
  amount: number;
}
export declare type OrderType =
  | "exchange limit"
  | "stop-limit"
  | "auction-only exchange limit"
  | "market buy"
  | "market sell"
  | "indication-of-interest";
export interface BaseOrder {
  side: "buy" | "sell";
  price?: string;
  symbol: string;
  order_id: string;
  client_order_id?: string;
  timestamp: string;
  timestampms: number;
  is_live: boolean;
  is_cancelled: boolean;
  is_hidden: boolean;
  remaining_amount?: string;
  original_amount?: string;
  executed_amount?: string;
}
export interface OrderStatus extends BaseOrder {
  id: string;
  exchange: "gemini";
  avg_execution_price: string;
  type: OrderType;
  options: [OrderEexecutionOptions] | [];
  reason?: string;
  trades?: PastTrade[];
  was_forced: boolean;
  stop_price?: string;
}
export interface CancelOrdersResponse {
  result: "ok";
  details: {
    cancelledOrders: number[];
    cancelRejects: number[];
  };
}
export interface PastTrade {
  price: string;
  amount: string;
  timestamp: number;
  timestampms: number;
  type: "Buy" | "Sell";
  aggressor: boolean;
  fee_currency: string;
  fee_amount: string;
  tid: number;
  order_id: string;
  client_order_id?: string;
  exchange?: "gemini";
  is_auction_fill: boolean;
  break?: string;
}
export interface NotionalVolume {
  account_id?: number;
  date: string;
  last_updated_ms: number;
  web_maker_fee_bps: number;
  web_taker_fee_bps: number;
  web_auction_fee_bps: number;
  api_maker_fee_bps: number;
  api_taker_fee_bps: number;
  api_auction_fee_bps: number;
  fix_maker_fee_bps: number;
  fix_taker_fee_bps: number;
  fix_auction_fee_bps: number;
  block_maker_fee_bps: number;
  block_taker_fee_bps: number;
  notional_30d_volume: number;
  notional_1d_volume: {
    date: string;
    notional_volume: number;
  }[];
}
export interface TradeVolume {
  account_id?: number;
  symbol: string;
  base_currency: string;
  notional_currency: string;
  data_date: string;
  total_volume_base: number;
  maker_buy_sell_ratio: number;
  buy_maker_base: number;
  buy_maker_notional: number;
  buy_maker_count: number;
  sell_maker_base: number;
  sell_maker_notional: number;
  sell_maker_count: number;
  buy_taker_base: number;
  buy_taker_notional: number;
  buy_taker_count: number;
  sell_taker_base: number;
  sell_taker_notional: number;
  sell_taker_count: number;
}
export interface NewClearingOrderResponse {
  result: string;
  clearing_id: string;
}
export interface ClearingOrderStatus {
  result: "ok";
  status:
    | "AwaitConfirm"
    | "AwaitSourceTargetConfirm"
    | "AwaitTargetConfirm"
    | "AwaitSourceConfirm"
    | "Confirmed"
    | "AttemptSettlement"
    | "Settled"
    | "Expired"
    | "Canceled"
    | "Not Found";
}
export interface CancelClearingOrderResponse {
  result: "ok" | "failed";
  details: string;
}
export interface ConfirmClearingOptionsResponse {
  result: "confirmed" | "error";
  reason?: string;
  message?: string;
}
export interface Balance {
  type: "exchange";
  currency: string;
  amount: string;
  available: string;
  availableForWithdrawal: string;
}
export interface NotionalBalance {
  currency: string;
  amount: string;
  amountNotional: string;
  available: string;
  availableNotional: string;
  availableForWithdrawal: string;
  availableForWithdrawalNotional: string;
}
export interface Transfer {
  type: "Deposit" | "Withdrawal";
  status: "Advanced" | "Complete";
  timestampms: number;
  eid: number;
  currency: string;
  amount: string;
  method?: "ACH" | "Wire";
  txHash?: string;
  outputIdx?: number;
  destination?: string;
  purpose?: string;
}
export interface DepositAddress {
  address: string;
  timestamp: number;
  label?: string;
}
export interface NewAddress {
  currency: string;
  address: string;
  label?: string;
}
export interface Withdrawal {
  address: string;
  amount: string;
  txHash?: string;
  withdrawalId?: string;
  message?: string;
}
export interface InternalTransferResponse {
  uuid: string;
}
export interface AddBankResponse {
  /** Reference ID for the new bank addition request. Once received, send in a wire from the requested bank account to verify it and enable withdrawals to that account. */
  referenceId: string;
}
export interface PaymentBalance {
  /** Account type. Will always be `exchange`. */
  type: "exchange";
  /**	Symbol for fiat balance. */
  currency: "USD";
  /** Total account balance for currency. */
  amount: string;
  /** Total amount available for trading */
  available: string;
  /** Total amount available for withdrawal */
  availableForWithdrawal: string;
}
export interface PaymentBank {
  /** Name of bank account */
  bank: string;
  /** Unique identifier for bank account */
  bankId: string;
}
export interface PaymentMethods {
  balances: PaymentBalance[];
  banks: PaymentBank[];
}
export interface SENWithdrawal {
  amount: string;
  withdrawalId: string;
  message: string;
}
export interface AccountInfo {
  name: string;
  account: string;
  type: "exchange" | "custody";
  counterparty_id: string;
  created: number;
}
export interface GUSDWithdrawal {
  destination: string;
  amount: string;
  txHash: string;
}
export interface Heartbeat {
  result: "ok";
}
export interface AuthenticatedClientOptions extends PublicClientOptions {
  key: string;
  secret: string;
}
export declare class AuthenticatedClient extends PublicClient {
  #private;
  constructor({ key, secret, ...rest }: AuthenticatedClientOptions);
  post<T = unknown>(
    path: string | undefined,
    _options: RequestInit | undefined,
    body?: {
      request: string;
    } & Record<string, unknown>
  ): Promise<T>;
  /** Submit a new order. */
  newOrder({ symbol, ...rest }: OrderOptions): Promise<OrderStatus>;
  /** Submit a new buy order. */
  buy({ symbol, ...rest }: BasicOrderOptions): Promise<OrderStatus>;
  /** Submit a new sell order. */
  sell({ symbol, ...rest }: BasicOrderOptions): Promise<OrderStatus>;
  /** Cancel an order. */
  cancelOrder(params: OrderID): Promise<OrderStatus>;
  /** Cancel all orders opened by this session. */
  cancelSession(account?: AccountName): Promise<CancelOrdersResponse>;
  /** Cancel all outstanding orders created by all sessions owned by this account. */
  cancelAll(account?: AccountName): Promise<CancelOrdersResponse>;
  /** Get an order status. */
  getOrderStatus(params: OrderID): Promise<OrderStatus>;
  /** Get all your live orders. */
  getActiveOrders(account?: AccountName): Promise<OrderStatus[]>;
  /** Get your past trades. */
  getPastTrades({
    symbol,
    limit_trades,
    ...rest
  }?: PastTradesFilter): Promise<PastTrade[]>;
  /** Get the volume in price currency that has been traded across all pairs over a period of 30 days. */
  getNotionalVolume(account?: AccountName): Promise<NotionalVolume>;
  /** Get the trade volume for each symbol. */
  getTradeVolume(account?: AccountName): Promise<TradeVolume[][]>;
  /** Submit a new clearing order. */
  newClearingOrder({
    symbol,
    ...rest
  }: ClearingOrderOptions): Promise<NewClearingOrderResponse>;
  /** Submit a new broker clearing order. */
  newBrokerOrder({
    symbol,
    ...rest
  }: BrokerOrderOptions): Promise<NewClearingOrderResponse>;
  /** Get a clearing order status. */
  getClearingOrderStatus(order: ClearingOrderID): Promise<ClearingOrderStatus>;
  /** Cancel a clearing order. */
  cancelClearingOrder(
    order: ClearingOrderID
  ): Promise<CancelClearingOrderResponse>;
  /** Confirm a clearing order. */
  confirmClearingOrder({
    symbol,
    ...rest
  }: ConfirmClearingOptions): Promise<ConfirmClearingOptionsResponse>;
  /** Get the available balances in the supported currencies. */
  getAvailableBalances(account?: AccountName): Promise<Balance[]>;
  /** Get the available balances in the supported currencies as well as in notional USD. */
  getNotionalBalances({
    currency,
    ...account
  }?: NotionalBalancesOptions): Promise<NotionalBalance[]>;
  /** Get deposits and withdrawals in the supported currencies. */
  getTransfers(rest?: TransferFilter): Promise<Transfer[]>;
  /** Get deposit addresses. */
  getDepositAddresses({
    network,
    ...rest
  }: DepositAddressesFilter): Promise<DepositAddress[]>;
  /** Get a new deposit address. */
  getNewAddress({ currency, ...rest }: NewAddressFilter): Promise<NewAddress>;
  /** Withdraw cryptocurrency funds to a whitelisted address. */
  withdrawCrypto({
    currency,
    ...rest
  }: WithdrawCryptoFilter): Promise<Withdrawal>;
  /** Make an internal transfer between any two exchange accounts within the Group. */
  internalTransfer({
    currency,
    ...rest
  }: InternalTransferFilter): Promise<InternalTransferResponse>;
  /** The add bank API allows for banking information to be sent in via API. However, for the bank to be verified, you must still send in a wire for any amount from the bank account. */
  addBank(bank: AddBankOptions): Promise<AddBankResponse>;
  /** Get data on balances in the account and linked banks */
  getPaymentMethods(account?: AccountName): Promise<PaymentMethods>;
  /** The SEN Withdrawals API allows you to withdraw USD from your Gemini account via SEN */
  withdrawSEN(options: SENWithdrawOptions): Promise<SENWithdrawal>;
  /** Get details about the specific account requested such as users, country codes, etc. */
  getAccountDetails(account?: AccountName): Promise<AccountDetails>;
  /** Create a new exchange account within the group. */
  createAccount(account: Account): Promise<Account>;
  /** Get the accounts within the group. */
  getAccounts(): Promise<AccountInfo[]>;
  /** Withdraw `USD` as `GUSD`. */
  withdrawGUSD(options: WithdrawGUSDFilter): Promise<GUSDWithdrawal>;
  /** Prevent a session from timing out and canceling orders if the require heartbeat flag has been set. */
  heartbeat(): Promise<Heartbeat>;
  set nonce(nonce: () => number);
  get nonce(): () => number;
}
