/// <reference types="node" />
import { EventEmitter } from "node:events";
import Websocket from "ws";
import { AccountName, BaseOrder, OrderType } from "./auth.js";
import { SymbolFilter, Candle } from "./public.js";
export declare const WsUri = "wss://api.gemini.com";
export declare const SandboxWsUri = "wss://api.sandbox.gemini.com";
export interface WSMarketQS {
  heartbeat?: boolean;
  top_of_book?: boolean;
  bids?: boolean;
  offers?: boolean;
  trades?: boolean;
  auctions?: boolean;
}
export declare type WSMarket = SymbolFilter & WSMarketQS;
export interface WSOrderQS {
  symbolFilter?: string | string[];
  apiSessionFilter?: string | string[];
  eventTypeFilter?: string | string[];
}
export declare type WSOrderOptions = WSOrderQS & AccountName;
export interface WSSignerOptions {
  request: string;
  nonce: number;
  account?: string;
}
export declare type Subscriptions = {
  name: string;
  symbols: string[];
}[];
export interface MessageV2 {
  type: "subscribe" | "unsubscribe";
  subscriptions: Subscriptions;
}
export interface ChangeEvent {
  type: "change";
  price: string;
  side: "bid" | "ask";
  reason: "place" | "trade" | "cancel" | "initial" | "top-of-book";
  remaining: string;
  delta?: string;
}
export interface TradeEvent {
  type: "trade";
  tid: number;
  price: string;
  amount: string;
  makerSide: "bid" | "ask" | "auction";
}
export interface BlockTradeEvent {
  type: "block_trade";
  tid: number;
  price: string;
  amount: string;
}
export interface AuctionOpenEvent {
  auction_open_ms: number;
  auction_time_ms: number;
  first_indicative_ms: number;
  last_cancel_time_ms: number;
  type: "auction_open";
}
export interface AuctionResultEvent {
  type: "auction_result";
  eid: number;
  result: "success" | "failure";
  time_ms: number;
  highest_bid_price: string;
  lowest_ask_price: string;
  collar_price: string;
  auction_price: string;
  auction_quantity: string;
}
export interface AuctionIndicativeEvent {
  type: "auction_indicative";
  eid: number;
  result: "success" | "failure";
  time_ms: number;
  highest_bid_price: string;
  lowest_ask_price: string;
  collar_price: string;
  indicative_price: string;
  indicative_quantity: string;
}
export declare type MarketDataEvent =
  | ChangeEvent
  | TradeEvent
  | BlockTradeEvent
  | AuctionOpenEvent
  | AuctionResultEvent
  | AuctionIndicativeEvent;
export interface HeartbeatMarketMessage {
  type: "heartbeat";
  socket_sequence: number;
}
export interface InitialUpdate {
  type: "update";
  socket_sequence: number;
  eventId: number;
  events: MarketDataEvent[];
}
export interface Update extends InitialUpdate {
  timestamp?: number;
  timestampms?: number;
}
export declare type MarketDataMessage =
  | HeartbeatMarketMessage
  | InitialUpdate
  | Update;
export interface SubscriptionAck {
  type: "subscription_ack";
  accountId: number;
  subscriptionId: string;
  symbolFilter: string[];
  apiSessionFilter: string[];
  eventTypeFilter: string[];
}
export interface HeartbeatOrdersMessage {
  type: "heartbeat";
  timestampms: number;
  sequence: number;
  trace_id: string;
  socket_sequence: number;
}
export interface BaseWSOrder extends BaseOrder {
  api_session: string;
  socket_sequence: number;
  behavior?: OrderType;
  order_type: string;
  avg_execution_price?: string;
  total_spend?: string;
}
export interface ActiveOrder extends BaseWSOrder {
  type: "initial";
}
export interface AcceptedOrder extends BaseWSOrder {
  type: "accepted";
}
export interface RejectedOrder extends BaseWSOrder {
  type: "rejected";
  reason: string;
}
export interface BookedOrder extends BaseWSOrder {
  type: "booked";
}
export interface FilledOrder extends BaseWSOrder {
  type: "fill";
  fill: {
    trade_id: string;
    liquidity: "Taker" | "Maker" | "Auction" | "Block" | "IndicatorOfInterest";
    price: string;
    amount: string;
    fee: string;
    fee_currency: string;
  };
}
export interface CancelledOrder extends BaseWSOrder {
  type: "cancelled";
  cancel_command_id?: string;
  reason?: string;
}
export interface CancelRejectedOrder extends BaseWSOrder {
  type: "cancel_rejected";
  cancel_command_id: string;
  reason: string;
}
export interface ClosedOrder extends BaseWSOrder {
  type: "closed";
}
export declare type Order =
  | ActiveOrder
  | AcceptedOrder
  | RejectedOrder
  | BookedOrder
  | FilledOrder
  | CancelledOrder
  | CancelRejectedOrder
  | ClosedOrder;
export declare type OrdersMessage =
  | SubscriptionAck
  | HeartbeatOrdersMessage
  | Order[];
export interface HeartbeatMarketV2 {
  type: "heartbeat";
  timestamp: number;
}
export interface L2Trade {
  type: "trade";
  symbol: string;
  eventid: number;
  timestamp: number;
  price: string;
  quantity: string;
  side: "buy" | "sell";
}
export interface L2Auction {
  type: "auction_indicative" | "auction_result";
  symbol: string;
  time_ms: number;
  result: "success" | "failure";
  highest_bid_price: string;
  lowest_ask_price: string;
  collar_price: string;
  auction_price: string;
  auction_quantity: string;
}
export interface L2Update {
  type: "l2_updates";
  symbol: string;
  changes: ["buy" | "sell", string, string][];
}
export interface L2InitialResponse extends L2Update {
  trades: L2Trade[];
  auction_events: L2Auction[];
}
export declare type L2Message =
  | L2InitialResponse
  | L2Trade
  | L2Auction
  | L2Update;
export declare type CandlesType =
  | "candles_1m_updates"
  | "candles_5m_updates"
  | "candles_15m_updates"
  | "candles_30m_updates"
  | "candles_1h_updates"
  | "candles_6h_updates"
  | "candles_1d_updates";
export interface CandlesUpdate {
  type: CandlesType;
  symbol: string;
  changes: Candle[];
}
export declare type MarketV2Message =
  | L2Message
  | CandlesUpdate
  | HeartbeatMarketV2;
export declare type WSMessage =
  | MarketDataMessage
  | OrdersMessage
  | MarketV2Message;
export interface WebsocketClientOptions extends SymbolFilter {
  sandbox?: boolean;
  wsUri?: string;
  key?: string;
  secret?: string;
}
export declare interface WebsocketClient {
  on(event: "open" | "close", eventListener: (market: string) => void): this;
  on(
    event: "message",
    eventListener: (data: WSMessage, market: string) => void
  ): this;
  on(
    event: "error",
    eventListener: (error: unknown, market: string) => void
  ): this;
  once(event: "open" | "close", eventListener: (market: string) => void): this;
  once(
    event: "message",
    eventListener: (data: WSMessage, market: string) => void
  ): this;
  once(
    event: "error",
    eventListener: (error: unknown, market: string) => void
  ): this;
}
export declare class WebsocketClient extends EventEmitter {
  #private;
  readonly wsUri: string;
  readonly symbol: string;
  readonly sockets: {
    [socket: string]: Websocket;
  };
  constructor({ symbol, sandbox, wsUri, key, secret }?: WebsocketClientOptions);
  /** Connect to the public API (V1) that streams all the market data on a given symbol. */
  connectMarket({ symbol, ...qs }?: WSMarket): Promise<void>;
  /** Disconnect from the public API (V1). */
  disconnectMarket({ symbol }?: SymbolFilter): Promise<void>;
  /** Connect to the private API that gives you information about your orders in real time. */
  connectOrders({ account, ...qs }?: WSOrderOptions): Promise<void>;
  /** Disconnect from the private API. */
  disconnectOrders(): Promise<void>;
  /** Connect to the public API (V2) that can stream all market and candle data across books. */
  connect(): Promise<void>;
  /** Disconnect from the public API (V2). */
  disconnect(): Promise<void>;
  /** Subscribe to data feeds (V2). */
  subscribe(subscriptions: Subscriptions): Promise<void>;
  /** Unsubscribe from data feeds (V2). */
  unsubscribe(subscriptions: Subscriptions): Promise<void>;
  set nonce(nonce: () => number);
  get nonce(): () => number;
}
