import fetch, { Headers } from "node-fetch";
export const DefaultTransform = "raw";
export class UnsuccessfulFetch extends Error {
  #response;
  constructor(message, response) {
    super(message);
    this.name = "UnsuccessfulFetch";
    this.#response = response;
  }
  get response() {
    return this.#response;
  }
}
export class FetchClient {
  #fetchOptions;
  #clientOptions;
  constructor(
    fetchOptions = {},
    { rejectNotOk = true, transform = DefaultTransform, baseUrl } = {}
  ) {
    const headers = new Headers(fetchOptions.headers);
    this.#fetchOptions = { ...fetchOptions, headers };
    this.#clientOptions = { rejectNotOk, baseUrl, transform };
  }
  get fetchOptions() {
    return this.#fetchOptions;
  }
  set fetchOptions(options) {
    this.#fetchOptions = FetchClient.#mergeFetchOptions(
      this.#fetchOptions,
      options
    );
  }
  get(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "GET" });
  }
  head(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "HEAD" });
  }
  post(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "POST" });
  }
  put(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "PUT" });
  }
  delete(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "DELETE" });
  }
  options(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "OPTIONS" });
  }
  trace(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "TRACE" });
  }
  patch(path = "", _fetchOptions = {}) {
    return this.fetch(path, { ..._fetchOptions, method: "PATCH" });
  }
  async fetch(path = "", options = {}) {
    const { baseUrl, rejectNotOk, transform } = this.#clientOptions;
    const url = new URL(path, baseUrl).toString();
    const fetchOptions = FetchClient.#mergeFetchOptions(
      this.#fetchOptions,
      options
    );
    const response = await fetch(url, fetchOptions);
    if (rejectNotOk && !response.ok) {
      throw new UnsuccessfulFetch(response.statusText, response);
    } else if (transform === "raw") {
      return response;
    }
    const data = await response[transform]();
    return data;
  }
  static #mergeFetchOptions(
    { headers: headers1, ...rest1 },
    { headers: headers2, ...rest2 }
  ) {
    const headers = new Headers(headers1);
    const _headers = new Headers(headers2);
    for (const [key, value] of _headers) {
      headers.set(key, value);
    }
    return { ...rest1, ...rest2, headers };
  }
}
export default FetchClient;
